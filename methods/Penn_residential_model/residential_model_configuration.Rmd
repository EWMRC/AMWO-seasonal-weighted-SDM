---
title: "R Notebook"
output: html_notebook
---
```{r}
library(tidyverse)
library(SDMtune)
library(here)
library(raster)
library(sp)
library(sf)
```

To do: add in state/federal route? Would be a PITA, but might prove informative.

Reading in the predictor datasets
```{r}
#500m
# lsm_500m_ai <- raster(here("methods", "Penn_migration_model", "lsm_500m", "lsm_ai_30m_500m_5070.tif"))
# names(lsm_500m_ai) <- "lsm_500m_ai"
# 
# lsm_500m_cohesion <- raster(here("methods", "Penn_migration_model", "lsm_500m", "lsm_cohesion_30m_500m_5070.tif"))
# names(lsm_500m_cohesion) <- "lsm_500m_cohesion"
# 
# lsm_500m_ed <- raster(here("methods", "Penn_migration_model", "lsm_500m", "lsm_ed_30m_500m_5070.tif"))
# names(lsm_500m_ed) <- "lsm_500m_ed"
# 
# lsm_500m_pland <- raster(here("methods", "Penn_migration_model", "lsm_500m", "lsm_pland_30m_500m_5070.tif"))
# names(lsm_500m_pland) <- "lsm_500m_pland"
# 
# lsm_500m_agri <- raster(here("methods", "Penn_migration_model", "lsm_500m", "lsm_agri_30m_500m_5070.tif"))
# names(lsm_500m_agri) <- "lsm_500m_agri"
# 
# lsm_500m_dev <- raster(here("methods", "Penn_migration_model", "lsm_500m", "lsm_dev_30m_500m_5070.tif"))
# names(lsm_500m_dev) <- "lsm_500m_dev"
# 
# #1km
# lsm_1km_ai <- raster(here("methods", "Penn_migration_model", "lsm_1km", "lsm_ai_90m_1km_5070.tif"))
# names(lsm_1km_ai) <- "lsm_1km_ai"
# 
# lsm_1km_cohesion <- raster(here("methods", "Penn_migration_model", "lsm_1km", "lsm_cohesion_90m_1km_5070.tif"))
# names(lsm_1km_cohesion) <- "lsm_1km_cohesion"
# 
# lsm_1km_ed <- raster(here("methods", "Penn_migration_model", "lsm_1km", "lsm_ed_90m_1km_5070.tif"))
# names(lsm_1km_ed) <- "lsm_1km_ed"
# 
# lsm_1km_pland <- raster(here("methods", "Penn_migration_model", "lsm_1km", "lsm_pland_90m_1km_5070.tif"))
# names(lsm_1km_pland) <- "lsm_1km_pland"
# 
# lsm_1km_agri <- raster(here("methods", "Penn_migration_model", "lsm_1km", "lsm_agri_90m_1km_5070.tif"))
# names(lsm_1km_agri) <- "lsm_1km_agri"
# 
# lsm_1km_dev <- raster(here("methods", "Penn_migration_model", "lsm_1km", "lsm_dev_90m_1km_5070.tif"))
# names(lsm_1km_dev) <- "lsm_1km_dev"
# 
# #5km
# lsm_5km_ai <- raster(here("methods", "Penn_migration_model", "lsm_5km", "lsm_ai_90m_5km_5070.tif"))
# names(lsm_5km_ai) <- "lsm_5km_ai"
# 
# lsm_5km_cohesion <- raster(here("methods", "Penn_migration_model", "lsm_5km", "lsm_cohesion_90m_5km_5070.tif"))
# names(lsm_5km_cohesion) <- "lsm_5km_cohesion"
# 
# lsm_5km_ed <- raster(here("methods", "Penn_migration_model", "lsm_5km", "lsm_ed_90m_5km_5070.tif"))
# names(lsm_5km_ed) <- "lsm_5km_ed"
# 
# lsm_5km_pland <- raster(here("methods", "Penn_migration_model", "lsm_5km", "lsm_pland_90m_5km_5070.tif"))
# names(lsm_5km_pland) <- "lsm_5km_pland"
# 
# lsm_5km_agri <- raster(here("methods", "Penn_migration_model", "lsm_5km", "lsm_agri_90m_5km_5070.tif"))
# names(lsm_5km_agri) <- "lsm_5km_agri"
# 
# lsm_5km_dev <- raster(here("methods", "Penn_migration_model", "lsm_5km", "lsm_dev_90m_5km_5070.tif"))
# names(lsm_5km_dev) <- "lsm_5km_dev"
# 
# #10km
# lsm_10km_ai <- raster(here("methods", "Penn_migration_model", "lsm_10km", "lsm_ai_90m_10km_5070.tif"))
# names(lsm_10km_ai) <- "lsm_10km_ai"
# 
# lsm_10km_cohesion <- raster(here("methods", "Penn_migration_model", "lsm_10km", "lsm_cohesion_90m_10km_5070.tif"))
# names(lsm_10km_cohesion) <- "lsm_10km_cohesion"
# 
# lsm_10km_ed <- raster(here("methods", "Penn_migration_model", "lsm_10km", "lsm_ed_90m_10km_5070.tif"))
# names(lsm_10km_ed) <- "lsm_10km_ed"
# 
# lsm_10km_pland <- raster(here("methods", "Penn_migration_model", "lsm_10km", "lsm_pland_90m_10km_5070.tif"))
# names(lsm_10km_pland) <- "lsm_10km_pland"
# 
# lsm_10km_agri <- raster(here("methods", "Penn_migration_model", "lsm_10km", "lsm_agri_90m_10km_5070.tif"))
# names(lsm_10km_agri) <- "lsm_10km_agri"
# 
# lsm_10km_dev <- raster(here("methods", "Penn_migration_model", "lsm_10km", "lsm_dev_90m_10km_5070.tif"))
# names(lsm_10km_dev) <- "lsm_10km_dev"
# 
# #landcover: set background values to NA
# forest_30m <- here("methods", "Penn_migration_model", "predictor_rasters", "nlcd2016_forestpatches.tif") %>% raster()
# forest_30m[forest_30m == 128] <- NA
# names(forest_30m) <- "forest_30m"
# 
# #terrain
# elev_30m <- there::here_file("Data", "DEM", "DEM_PA_30m.tif") %>% raster()
# names(elev_30m) <- "elev_30m"
# 
# slope_30m <- here("methods", "Penn_migration_model", "topographic_wetness_index", "DEM_PA_30slope.tif") %>% raster()
# names(slope_30m) <- "slope_30m"
# 
# #moisture: replace NAs with the mean value
# soil_drainage_30m <- there::here_file("Data", "SoilDrainage", "soil_drainage_5070.tif") %>% raster()
# names(soil_drainage_30m) <- "soil_drainage_30m"
# 
# soil_drainage_30m %>%
#   values() %>%
#   mean(na.rm = TRUE) ->
#   soil_drainage_30m[is.na(soil_drainage_30m)]
# 
# twi_30m <- here("methods", "Penn_migration_model", "topographic_wetness_index", "DEM_PA_30m_twi.tif") %>% raster()
# names(twi_30m) <- "twi_30m"
# 
# #level 3 ecoregions
# ecoregions <- there::here_file("Data", "physiographic_provinces", "level_iii_ecoregions_pa.tif") %>% raster()
# names(ecoregions) <- "ecoregions"
# 
# #succession classes
# sclass <- there::here_file("Data", "Landfire_products", "US_200SCLASS", "us_200sclass_pa.tif") %>% raster()
# names(sclass) <- "sclass"
```

Resampling to a shared resolution and placing in a predictorstack (which will be saved and used again later)
```{r}
# predictor_list_full <- c(lsm_500m_ai, lsm_500m_cohesion, lsm_500m_ed, lsm_500m_pland, lsm_500m_agri, lsm_500m_dev, lsm_1km_ai, lsm_1km_cohesion, lsm_1km_ed, lsm_1km_pland, lsm_1km_agri, lsm_1km_dev, lsm_5km_ai, lsm_5km_cohesion, lsm_5km_ed, lsm_5km_pland, lsm_5km_agri, lsm_5km_dev, lsm_10km_ai, lsm_10km_cohesion, lsm_10km_ed, lsm_10km_pland, lsm_10km_agri, lsm_10km_dev, forest_30m, elev_30m, slope_30m, soil_drainage_30m, twi_30m, ecoregions, sclass)
# 
# cl <- parallel::makeCluster(4)
# parallel::clusterExport(cl, c("lsm_500m_ai", "lsm_500m_cohesion", "lsm_500m_ed", "lsm_500m_pland", "lsm_500m_agri", "lsm_500m_dev", "lsm_1km_ai", "lsm_1km_cohesion", "lsm_1km_ed", "lsm_1km_pland", "lsm_1km_agri", "lsm_1km_dev", "lsm_5km_ai", "lsm_5km_cohesion", "lsm_5km_ed", "lsm_5km_pland", "lsm_5km_agri", "lsm_5km_dev", "lsm_10km_ai", "lsm_10km_cohesion", "lsm_10km_ed", "lsm_10km_pland", "lsm_10km_agri", "lsm_10km_dev", "forest_30m", "elev_30m", "slope_30m", "soil_drainage_30m", "twi_30m", "ecoregions", "sclass", "predictor_list_full"))
# 
# parallel::clusterEvalQ(cl, library(tidyverse))
# parallel::clusterEvalQ(cl, library(sp))
# parallel::clusterEvalQ(cl, library(sf))
# parallel::clusterEvalQ(cl, library(raster))
# parallel::clusterEvalQ(cl, library(here))
# 
# predictor_list_full <- pbapply::pblapply(X = predictor_list_full, cl = cl, FUN = function(x){
#   resample(x, forest_30m, filename = here("methods", "Penn_migration_model", "predictor_rasters_resampled", paste0(names(x), ".grd")), overwrite = TRUE)
# })
# 
# predictor_stack_full <- do.call(what = raster::stack, args = c(predictor_list_full, quick = FALSE))
# 
# names(predictor_stack_full) <- c("lsm_500m_ai", "lsm_500m_cohesion", "lsm_500m_ed", "lsm_500m_pland", "lsm_500m_agri", "lsm_500m_dev", "lsm_1km_ai", "lsm_1km_cohesion", "lsm_1km_ed", "lsm_1km_pland", "lsm_1km_agri", "lsm_1km_dev", "lsm_5km_ai", "lsm_5km_cohesion", "lsm_5km_ed", "lsm_5km_pland", "lsm_5km_agri", "lsm_5km_dev", "lsm_10km_ai", "lsm_10km_cohesion", "lsm_10km_ed", "lsm_10km_pland", "lsm_10km_agri", "lsm_10km_dev", "forest_30m", "elev_30m", "slope_30m", "soil_drainage_30m", "twi_30m", "ecoregions", "sclass")
# 
# stackSave(predictor_stack_full, here("methods", "Penn_migration_model", "predictor_stack_full_mig.stk"))
```

Read in preprocessed available data
```{r}
predictor_stack_full <- stackOpen(here("methods", "Penn_migration_model", "predictor_stack_full_mig.stk"))

names(predictor_stack_full) <- c("lsm_500m_ai", "lsm_500m_cohesion", "lsm_500m_ed", "lsm_500m_pland", "lsm_500m_agri", "lsm_500m_dev", "lsm_1km_ai", "lsm_1km_cohesion", "lsm_1km_ed", "lsm_1km_pland", "lsm_1km_agri", "lsm_1km_dev", "lsm_5km_ai", "lsm_5km_cohesion", "lsm_5km_ed", "lsm_5km_pland", "lsm_5km_agri", "lsm_5km_dev", "lsm_10km_ai", "lsm_10km_cohesion", "lsm_10km_ed", "lsm_10km_pland", "lsm_10km_agri", "lsm_10km_dev", "forest_30m", "elev_30m", "slope_30m", "soil_drainage_30m", "twi_30m", "ecoregions", "sclass")
```

Read in the used points, and transform the used and available points to match the predictor stack
```{r}
set.seed(8)

pa_sgs_pres_abs <- read_csv(here("methods", "Penn_residential_model", "sgs", "pa_sgs_pres_abs.csv")) %>%
  filter(!is.na(Latitude)) %>%
  mutate(survey_type = 0) %>%
  distinct(Latitude, Longitude, .keep_all = TRUE) %>% 
  group_by(Route) %>%
  sample_n(1)

set.seed(8)

state_surveys <- read_csv(here("methods", "Penn_residential_model", "PA_state_surveys", "pa_statesurveys_pres_abs.csv")) %>%
  filter(!is.na(Latitude)) %>%
  mutate(survey_type = 1) %>%
  mutate(Stop = as.character(Stop)) %>%
  distinct(Latitude, Longitude, .keep_all = TRUE) %>% 
  group_by(Route) %>%
  sample_n(1)

surveys_all <- bind_rows(pa_sgs_pres_abs, state_surveys)  %>%
  distinct(Latitude, Longitude, .keep_all = TRUE)

used <- surveys_all %>%
  filter(pres_abs == 1) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
  st_transform(crs = st_crs(predictor_stack_full)) %>% 
  as_Spatial()

avail <- surveys_all %>%
  filter(pres_abs == 0) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
  st_transform(crs = st_crs(predictor_stack_full)) %>%
  as_Spatial()
```

Prep SDMs
```{r}
swd_full <- prepareSWD(species = "Scolopax minor", 
           env = terra::rast(predictor_stack_full), 
           p = rename(as.data.frame(used@coords), x = coords.x1, y = coords.x2), 
           a = as.data.frame(avail@coords),
           categorical = c("forest_30m", "ecoregions", "sclass", "soil_drainage_30m"))

# Split presence locations in training (80%) and testing (20%) datasets
# datasets <- trainValTest(swd_full,
#                          test = 0.2,
#                          only_presence = FALSE,
#                          seed = 8)
# train <- datasets[[1]]
# test <- datasets[[2]]
kfolds <- randomFolds(data = swd_full, k = 5, seed = 8)
```

Training a basic, full model
```{r}
model <- train(method = "RF",
               data = swd_full,
               folds = kfolds,
               ntree = 2000)

auc(model, test = TRUE) #0.6930535
tss(model, test = TRUE) #0.4037707
```

# Remove variables with high correlation

Generate background coordinates, which can be used to assess correlation between predictor variables
```{r}
avail_unbiased <- readRDS(here("methods", "Penn_migration_model", "avail_unbiased.rds"))

set.seed(8)

bg_coords <- avail_unbiased %>%
  st_as_sf() %>% 
  st_transform(st_crs(predictor_stack_full)) %>% 
  slice_sample(n = 1000) %>% 
  as_Spatial()
```

```{r}
bg <- prepareSWD(species = "Correlation test",
                 a = bg_coords,
                 env = terra::rast(predictor_stack_full))

results_vs <- varSel(model,
             metric = "auc",
             bg4cor = bg,
             #test = test,
             cor_th = 0.7, #cite the SDMTune paper
             permut = 25) #25 (see Geneur et al. 2015)
results_vs
```
Keeping: 
• Continuous: "lsm_1km_dev", "lsm_10km_ed", "lsm_10km_pland", "lsm_10km_agri",
"lsm_10km_dev", "elev_30m", "slope_30m", and "twi_30m"
• Categorical: "soil_drainage_30m", "ecoregions", and "sclass"

# Tune hyperparameters
```{r}
env_hp <- terra::rast(predictor_stack_full)

env_hp <- subset(env_hp, c("lsm_1km_dev", "lsm_10km_ed", "lsm_10km_pland", "lsm_10km_agri",
"lsm_10km_dev", "elev_30m", "slope_30m", "twi_30m", "soil_drainage_30m", "ecoregions", "sclass"))

swd_hp <- prepareSWD(species = "Scolopax minor", 
           env = env_hp, 
           p = rename(as.data.frame(used@coords), x = coords.x1, y = coords.x2), 
           a = as.data.frame(avail@coords),
           categorical = c("soil_drainage_30m", "ecoregions", "sclass"))

# Split presence locations in training (80%) and testing (20%) datasets
# datasets_hp <- trainValTest(swd_hp,
#                          test = 0.2,
#                          only_presence = FALSE,
#                          seed = 8)
# 
# train_hp <- datasets_hp[[1]]
# test_hp <- datasets_hp[[2]]

kfolds_hp <- randomFolds(data = swd_hp, k = 5, seed = 8)

model_hp <- train(method = "RF",
               data = swd_hp,
               folds = kfolds_hp)

hypers <- list(mtry=1:8,
              ntree = seq(from = 100, to = 3000, by = 100),
              nodesize = 1:10)

tuned_hypers <- optimizeModel(model = model_hp,
                     hypers = hypers,
                     metric = "auc",
                     #test = test_hp,
                     seed = 8)

tuned_hypers@models[[1]] #use the hyperparameters from the best model going forward

tuned_mtry_1 <- tuned_hypers@models[[1]]@models[[1]]@model@mtry
tuned_ntree_1 <- tuned_hypers@models[[1]]@models[[1]]@model@ntree
tuned_nodesize_1 <- tuned_hypers@models[[1]]@models[[1]]@model@nodesize
```

mtry: 1
ntree: 1100
nodesize: 6

# Eliminate variables with small variable importance
```{r}
env_vi <- terra::rast(predictor_stack_full)

#colnames(results_vi@data@data)

env_vi <- subset(env_vi, c("lsm_10km_ed", "lsm_10km_pland", "lsm_10km_agri", "lsm_10km_dev",
"elev_30m", "slope_30m", "twi_30m", "soil_drainage_30m", "ecoregions", "sclass"))

swd_vi <- prepareSWD(species = "Scolopax minor", 
           env = env_vi, 
           p = rename(as.data.frame(used@coords), x = coords.x1, y = coords.x2), 
           a = as.data.frame(avail@coords),
           categorical = c("ecoregions", "sclass", "soil_drainage_30m"))

# Split presence locations in training (80%) and testing (20%) datasets
# datasets_vi <- trainValTest(swd_vi,
#                          test = 0.2,
#                          only_presence = FALSE,
#                          seed = 8)
# 
# train_vi <- datasets_vi[[1]]
# test_vi <- datasets_vi[[2]]

kfolds_vi <- randomFolds(data = swd_vi, k = 5, seed = 8)

model_vi <- train(method = "RF",
               data = swd_vi,
               folds = kfolds_vi,
               mtry = tuned_mtry_1,
               ntree = tuned_ntree_1,
               nodesize = tuned_nodesize_1)

results_vi <- reduceVar(model = model_vi,
          th = 2, #cite the SDMTune paper
          #test = test_vi,
          use_jk = TRUE,
          metric = "auc",
          permut = 25) #25 (see Geneur et al. 2015)

results_vi
auc(results_vi, test = TRUE)
```
Final variables:
• Continuous: "lsm_10km_agri", "lsm_10km_dev", "elev_30m", and "slope_30m"
• Categorical: "soil_drainage_30m", "ecoregions", and "sclass"

Retune hyperparameters for the final model (which is in a separate script)
```{r}
env_hp2 <- terra::rast(predictor_stack_full)

env_hp2 <- subset(env_vi, c("lsm_10km_agri", "lsm_10km_dev", "elev_30m", "slope_30m", "soil_drainage_30m", "ecoregions", "sclass"))

swd_hp2 <- prepareSWD(species = "Scolopax minor", 
           env = env_hp2, 
           p = rename(as.data.frame(used@coords), x = coords.x1, y = coords.x2), 
           a = as.data.frame(avail@coords),
           categorical = c("soil_drainage_30m", "ecoregions", "sclass"))

# Split presence locations in training (80%) and testing (20%) datasets
# datasets_hp2 <- trainValTest(swd_hp2,
#                          test = 0.2,
#                          only_presence = FALSE,
#                          seed = 8)
# 
# train_hp2 <- datasets_hp2[[1]]
# test_hp2 <- datasets_hp2[[2]]

kfolds_hp2 <- randomFolds(data = swd_hp2, k = 5, seed = 8)

model_hp2 <- train(method = "RF",
               data = swd_hp2,
               folds = kfolds_hp2,
               mtry = tuned_mtry_1,
               ntree = tuned_ntree_1,
               nodesize = tuned_nodesize_1)

hypers2 <- list(mtry=1:7,
              ntree = seq(from = 100, to = 3000, by = 100),
              nodesize = 1:10)

tuned_hypers_2 <- optimizeModel(model = model_hp2,
                     hypers = hypers2,
                     metric = "auc",
                     #test = test_hp2,
                     seed = 8)

tuned_hypers_2@models[[1]] #use the hyperparameters from the best model going forward
tuned_hypers_2@models[[1]] %>% auc(test = TRUE) #0.6603632
tuned_hypers_2@models[[1]] %>% tss(test = TRUE) #0.3863248
```

mtry: 1
ntree: 1300
nodesize: 7

