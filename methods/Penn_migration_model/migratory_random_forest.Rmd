---
title: "R Notebook"
output: html_notebook
---

```{r}
library(sp)
library(raster)
library(tidyverse)
library(there)
library(sf)
library(stars)
library(SDMtune)
```

Reading in the predictor datasets
```{r}
# #500m
# lsm_500m_ai <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_500m", "lsm_ai_30m_500m_5070.tif"))
# names(lsm_500m_ai) <- "lsm_500m_ai"
# 
# lsm_500m_cohesion <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_500m", "lsm_cohesion_30m_500m_5070.tif"))
# names(lsm_500m_cohesion) <- "lsm_500m_cohesion"
# 
# lsm_500m_ed <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_500m", "lsm_ed_30m_500m_5070.tif"))
# names(lsm_500m_ed) <- "lsm_500m_ed"
# 
# lsm_500m_pland <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_500m", "lsm_pland_30m_500m_5070.tif"))
# names(lsm_500m_pland) <- "lsm_500m_pland"
# 
# lsm_500m_agri <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_500m", "lsm_agri_30m_500m_5070.tif"))
# names(lsm_500m_agri) <- "lsm_500m_agri"
# 
# lsm_500m_dev <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_500m", "lsm_dev_30m_500m_5070.tif"))
# names(lsm_500m_dev) <- "lsm_500m_dev"
# 
# #1km
# lsm_1km_ai <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_1km", "lsm_ai_90m_1km_5070.tif"))
# names(lsm_1km_ai) <- "lsm_1km_ai"
# 
# lsm_1km_cohesion <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_1km", "lsm_cohesion_90m_1km_5070.tif"))
# names(lsm_1km_cohesion) <- "lsm_1km_cohesion"
# 
# lsm_1km_ed <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_1km", "lsm_ed_90m_1km_5070.tif"))
# names(lsm_1km_ed) <- "lsm_1km_ed"
# 
# lsm_1km_pland <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_1km", "lsm_pland_90m_1km_5070.tif"))
# names(lsm_1km_pland) <- "lsm_1km_pland"
# 
# lsm_1km_agri <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_1km", "lsm_agri_90m_1km_5070.tif"))
# names(lsm_1km_agri) <- "lsm_1km_agri"
# 
# lsm_1km_dev <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_1km", "lsm_dev_90m_1km_5070.tif"))
# names(lsm_1km_dev) <- "lsm_1km_dev"
# 
# #5km
# lsm_5km_ai <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_5km", "lsm_ai_90m_5km_5070.tif"))
# names(lsm_5km_ai) <- "lsm_5km_ai"
# 
# lsm_5km_cohesion <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_5km", "lsm_cohesion_90m_5km_5070.tif"))
# names(lsm_5km_cohesion) <- "lsm_5km_cohesion"
# 
# lsm_5km_ed <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_5km", "lsm_ed_90m_5km_5070.tif"))
# names(lsm_5km_ed) <- "lsm_5km_ed"
# 
# lsm_5km_pland <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_5km", "lsm_pland_90m_5km_5070.tif"))
# names(lsm_5km_pland) <- "lsm_5km_pland"
# 
# lsm_5km_agri <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_5km", "lsm_agri_90m_5km_5070.tif"))
# names(lsm_5km_agri) <- "lsm_5km_agri"
# 
# lsm_5km_dev <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_5km", "lsm_dev_90m_5km_5070.tif"))
# names(lsm_5km_dev) <- "lsm_5km_dev"
# 
# #10km
# lsm_10km_ai <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_10km", "lsm_ai_90m_10km_5070.tif"))
# names(lsm_10km_ai) <- "lsm_10km_ai"
# 
# lsm_10km_cohesion <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_10km", "lsm_cohesion_90m_10km_5070.tif"))
# names(lsm_10km_cohesion) <- "lsm_10km_cohesion"
# 
# lsm_10km_ed <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_10km", "lsm_ed_90m_10km_5070.tif"))
# names(lsm_10km_ed) <- "lsm_10km_ed"
# 
# lsm_10km_pland <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_10km", "lsm_pland_90m_10km_5070.tif"))
# names(lsm_10km_pland) <- "lsm_10km_pland"
# 
# lsm_10km_agri <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_10km", "lsm_agri_90m_10km_5070.tif"))
# names(lsm_10km_agri) <- "lsm_10km_agri"
# 
# lsm_10km_dev <- raster(here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "lsm_10km", "lsm_dev_90m_10km_5070.tif"))
# names(lsm_10km_dev) <- "lsm_10km_dev"
# 
# #landcover: set background values to NA
# forest_30m <- here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "nlcd2016_forestpatches.tif") %>% raster() 
# forest_30m[forest_30m == 128] <- NA
# names(forest_30m) <- "forest_30m"
# 
# #terrain
# elev_30m <- here_file("Data", "DEM", "DEM_PA_30m.tif") %>% raster()
# names(elev_30m) <- "elev_30m"
# 
# slope_30m <- here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "topographic_wetness_index", "DEM_PA_30slope.tif") %>% raster()
# names(slope_30m) <- "slope_30m"
# 
# #moisture: replace NAs with the mean value
# soil_drainage_30m <- here_file("Data", "SoilDrainage", "soil_drainage_5070.tif") %>% raster()
# names(soil_drainage_30m) <- "soil_drainage_30m"
# 
# soil_drainage_30m %>% 
#   values() %>%
#   mean(na.rm = TRUE) ->
#   soil_drainage_30m[is.na(soil_drainage_30m)]
# 
# twi_30m <- here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "topographic_wetness_index", "DEM_PA_30m_twi.tif") %>% raster()
# names(twi_30m) <- "twi_30m"
# 
# #level 3 ecoregions
# ecoregions <- here_file("Data", "physiographic_provinces", "level_iii_ecoregions_pa.tif") %>% raster()
# names(ecoregions) <- "ecoregions"
# 
# #succession classes
# sclass <- here_file("Data", "Landfire_products", "US_200SCLASS", "us_200sclass_pa.tif") %>% raster()
# names(sclass) <- "sclass"
```

Creating a set of 10,000 unbiased and biased available points. I've checked these to make sure the function is working correctly. Save so this can be reloaded and doesn't need to be rerun.
```{r}
# set.seed(8)
# avail_unbiased <- enmSdmX::sampleRast(x = projectRaster(forest_30m, crs = crs("+init=epsg:4326")), n = 10000, replace = TRUE, prob = FALSE) %>%
#   as.data.frame()
# # avail_biased <- enmSdm::sampleRast(x = pa_mig_corridor_4326, n = 10000, replace = TRUE, prob = TRUE) %>%
# #   as.data.frame()
# 
# coordinates(avail_unbiased) <- ~ x + y
# # coordinates(avail_biased) <- ~ x + y
# 
# proj4string(avail_unbiased) <- CRS("+init=epsg:4326")
# # proj4string(avail_biased) <- CRS("+init=epsg:4326")
# saveRDS(avail_unbiased, file = "avail_unbiased.rds")
avail_unbiased <- readRDS("avail_unbiased.rds")
```

Using resample to get all of the rasters on matching extents and resolutions before I put them in a rasterstack. This is prerun and can be reloaded.
```{r}
# #full/threshold variables
# predictor_list_full <- c(lsm_500m_ai, lsm_500m_cohesion, lsm_500m_ed, lsm_500m_pland, lsm_500m_agri, lsm_500m_dev, lsm_1km_ai, lsm_1km_cohesion, lsm_1km_ed, lsm_1km_pland, lsm_1km_agri, lsm_1km_dev, lsm_5km_ai, lsm_5km_cohesion, lsm_5km_ed, lsm_5km_pland, lsm_5km_agri, lsm_5km_dev, lsm_10km_ai, lsm_10km_cohesion, lsm_10km_ed, lsm_10km_pland, lsm_10km_agri, lsm_10km_dev, forest_30m, elev_30m, slope_30m, soil_drainage_30m, twi_30m, ecoregions, sclass)
# 
# cl <- parallel::makeCluster(8)
# parallel::clusterExport(cl, c("lsm_500m_ai", "lsm_500m_cohesion", "lsm_500m_ed", "lsm_500m_pland", "lsm_500m_agri", "lsm_500m_dev", "lsm_1km_ai", "lsm_1km_cohesion", "lsm_1km_ed", "lsm_1km_pland", "lsm_1km_agri", "lsm_1km_dev", "lsm_5km_ai", "lsm_5km_cohesion", "lsm_5km_ed", "lsm_5km_pland", "lsm_5km_agri", "lsm_5km_dev", "lsm_10km_ai", "lsm_10km_cohesion", "lsm_10km_ed", "lsm_10km_pland", "lsm_10km_agri", "lsm_10km_dev", "forest_30m", "elev_30m", "slope_30m", "soil_drainage_30m", "twi_30m", "ecoregions", "sclass", "predictor_list_full"))
# 
# parallel::clusterEvalQ(cl, library(tidyverse))
# parallel::clusterEvalQ(cl, library(sp))
# parallel::clusterEvalQ(cl, library(sf))
# parallel::clusterEvalQ(cl, library(raster))
# parallel::clusterEvalQ(cl, library(there))
# 
# predictor_list_full <- pbapply::pblapply(X = predictor_list_full, cl = cl, FUN = function(x){
#   resample(x, forest_30m, filename = here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "predictor_rasters_resampled", paste0(names(x), ".grd")))
# })
# 
# predictor_stack_full <- do.call(what = raster::stack, args = c(predictor_list_full, quick = FALSE))
# 
# names(predictor_stack_full) <- c("lsm_500m_ai", "lsm_500m_cohesion", "lsm_500m_ed", "lsm_500m_pland", "lsm_500m_agri", "lsm_500m_dev", "lsm_1km_ai", "lsm_1km_cohesion", "lsm_1km_ed", "lsm_1km_pland", "lsm_1km_agri", "lsm_1km_dev", "lsm_5km_ai", "lsm_5km_cohesion", "lsm_5km_ed", "lsm_5km_pland", "lsm_5km_agri", "lsm_5km_dev", "lsm_10km_ai", "lsm_10km_cohesion", "lsm_10km_ed", "lsm_10km_pland", "lsm_10km_agri", "lsm_10km_dev", "forest_30m", "elev_30m", "slope_30m", "soil_drainage_30m", "twi_30m", "ecoregions", "sclass")
# 
# predictor_stack_interpretation <- predictor_stack_full %>%
#   subset(subset = c("lsm_500m_cohesion", "lsm_500m_pland", "lsm_1km_cohesion", "lsm_1km_pland", "lsm_5km_cohesion", "lsm_5km_pland"))
# 
# 
# predictor_stack_prediction <- predictor_stack_full %>%
#   subset(subset = c("lsm_500m_pland")) %>%
#   raster::stack()
# 
# stackSave(predictor_stack_full, "predictor_stack_full_mig.stk")
# stackSave(predictor_stack_interpretation, "predictor_stack_interp_mig.stk")
# stackSave(predictor_stack_prediction, "predictor_stack_predict_mig.stk")

predictor_stack_full <- stackOpen("predictor_stack_full_mig.stk")
predictor_stack_interpretation <- stackOpen("predictor_stack_interp_mig.stk")
predictor_stack_prediction <- stackOpen("predictor_stack_predict_mig.stk")
```

Read in the used points, and transform the used and available points to match the predictor stack
```{r}
used <- st_read(dsn = here_file("Data", "movebank_locations", "dispersing_points_pa_6_2_2021.shp")) %>% 
  st_transform(st_crs(predictor_stack_full)) %>% 
  as_Spatial() 

avail_unbiased <- avail_unbiased %>%
  st_as_sf() %>% 
  st_transform(st_crs(predictor_stack_full)) %>% 
  as_Spatial()
```

# Prepping datasets for the model runs: one for each VSURF category
Full
```{r}
swd_full <- prepareSWD(species = "Scolopax minor", 
           env = terra::rast(predictor_stack_full), 
           p = rename(as.data.frame(used@coords), x = coords.x1, y = coords.x2), 
           a = as.data.frame(avail_unbiased@coords))

swd_full_folds <- randomFolds(swd_full, k = 5, only_presence = TRUE, seed = 8)

#Random Forest
rf_full <- train(method = "RF", data = swd_full, swd_full_folds, ntree = 2000)

auc(rf_full, test = TRUE) #0.7834553
#The TSS scores are measured from 1 to + 1, with 1 signifying perfect agreement and 0.60 to 0.90 suggesting good to excellent model performance (Allouche et al.
tss(rf_full, test = TRUE) #0.478331
```

Interpretation
```{r}
swd_interpretation <- prepareSWD(species = "Scolopax minor", 
           env = terra::rast(predictor_stack_interpretation), 
           p = rename(as.data.frame(used@coords), x = coords.x1, y = coords.x2), 
           a = as.data.frame(avail_unbiased@coords))

swd_interpretation_folds <- randomFolds(swd_interpretation, k = 5, only_presence = TRUE, seed = 8)

rf_interpretation <- train(method = "RF", data = swd_interpretation, swd_interpretation_folds, ntree = 2000)

auc(rf_interpretation, test = TRUE) #0.636322
tss(rf_interpretation, test = TRUE) #0.2449403
```

Prediction- single variable in the prediction dataset, so I can't run this
```{r}
# swd_prediction <- prepareSWD(species = "Scolopax minor", 
#            env = terra::rast(predictor_stack_prediction), 
#            p = rename(as.data.frame(used@coords), x = coords.x1, y = coords.x2), 
#            a = as.data.frame(avail_unbiased@coords))
# 
# swd_prediction_folds <- randomFolds(swd_prediction, k = 5, only_presence = TRUE, seed = 8)
# 
# rf_prediction <- train(method = "RF", data = swd_prediction, swd_prediction_folds, ntree = 2000)
# 
# auc(rf_prediction, test = TRUE) #0.7834553
```

Old code: Running and evaluating MaxEnt and BRT models
```{r}
#Maxent
maxent_full <- train(method = "Maxent", data = swd_full, swd_full_folds)

auc(maxent_full, test = TRUE) #0.6829508 new  0.6632222 high res 0.6348439
# threshold 0.66
# auc(maxent_biased, test = TRUE) #0.6995317 new 0.6792424 high res 0.6536735
# threshold 0.62

#Random Forest
# rf_full <- train(method = "RF", data = swd_full, swd_full_folds, ntree = 2000)
# 
# auc(rf_full, test = TRUE) #0.8117838 new 0.6925512 high res 0.7904723
# threshold 0.819873 # interp 0.8112176 # predict 0.7703317
# threshold w/ new data: 0.855862
# auc(rf_biased, test = TRUE) #0.7920476 new 0.7009309 high res 0.7750536
# threshold 0.8138423 # interp 0.8034353 # predict 0.7796286
# w/ bug fixes
# threshold 0.780539 interp 0.6404059

#Boosted Regression Trees
brt_unbiased <- train(method = "BRT", data = swd_full, swd_full_folds)

auc(brt_full, test = TRUE) #0.6315634 new 0.6076869 high res 0.6227524
# auc(brt_biased, test = TRUE) #0.6297118 new 0.6348771 high res 0.6229736
```

# Making a prediction layer
Cutting using a fishnet for parallel processing
```{r}
fishnet <- st_read(here_file("Projects", "Penn_residential_model", "pa_fishnet_300.shp")) %>%
  st_transform(crs(predictor_stack))

for(i in 1:nrow(fishnet)){
  temp_extent <- fishnet[i,] %>% as_Spatial() %>% extent()
  crop(x = predictor_stack, y = temp_extent, 
       filename = paste0("predictor_stack_adv/predictor_stack_adv_30m_smol_",i,".grd")) 
}
```


```{r}
library(parallel)
cl_new <- makeCluster(10)
clusterEvalQ(cl_new, library(raster))
clusterEvalQ(cl_new, library(SDMtune))
clusterEvalQ(cl_new, library(randomForest))
clusterExport(cl_new, c("rf_unbiased"))

Sys.time()

walk_results <- clusterApplyLB(cl = cl_new, x = 1:305, fun = function(i){
  predictor_stack_iter <- raster::stack(paste0("predictor_stack_adv/predictor_stack_adv_30m_smol_", i, ".grd"))
  rf_unbiased_map <- predict(rf_unbiased, data = predictor_stack_iter, type = "cloglog")
  writeRaster(rf_unbiased_map, paste0("mig_tiles_adv/rf_unbiased_6_15_21_",i,".tif"))
})

# walk_results <- pbapply::pblapply(cl = cl_new, X = 1:305, FUN = function(i){
#   predictor_stack_iter <- raster::stack(paste0("predictor_stack_adv/predictor_stack_adv_30m_smol_", i, ".grd"))
#   rf_unbiased_map <- predict(rf_unbiased, data = predictor_stack_iter, type = "cloglog")
#   writeRaster(rf_unbiased_map, paste0("mig_tiles_adv/rf_unbiased_6_15_21_",i,".tif"))
# })

Sys.time()

stopCluster(cl_new)
```

Merging tiles
```{r}
here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "mig_tiles_adv") %>%
  list.files() ->
  tile_names

tile_rasters <- map(tile_names, function(x){
  here_file("Projects", "AMWO-seasonal-weighted-SDM", "code", "Penn_migration_model", "mig_tiles_adv", x) %>%
    raster()
})

merged_rasters <- tile_rasters[[1]]

for(i in 2:length(tile_rasters)){
  merged_rasters <- raster::merge(merged_rasters, tile_rasters[[i]])
}

writeRaster(merged_rasters, "rf_unbiased_6_16_21.tif")
```

Predict woodcock stopover locations
```{r}
# rf_unbiased_map <- predict(rf_unbiased, data = predictor_stack, type = "cloglog", progress = "text", cl = 10)
# writeRaster(rf_unbiased_map, "rf_unbiased_6_14_21.tif")
```

Evaluating variable importance
```{r}
rf_jacknifed <- doJk(rf_full, metric = "auc")
rf_jacknifed
```

layer 1 : forest 30m, layer 2: soil drainage

Forest (delta AUC 0.0455421) and slope (delta AUC 0.017146) are important single variables
Elev (delta AUC -0.0112486) is not important 

However, none of these variables are very informative when used on their own (so random forest is a good choice)
```{r}
plotJk(rf_jacknifed, type = "test", ref = auc(rf_biased, test = TRUE))
#ggsave("variable_importance_1_24_21.jpg")
```

Building a set of test models for suite jacknifing
```{r}
#exclude landscape suite
predictor_list_nolandscape <- c(forest_30m, elev_30m, slope_30m, soil_drainage_30m, twi_30m)

predictor_list_nolandscape <- map(predictor_list_nolandscape, function(x){
  resample(x, forest_30m)
})

predictor_stack_nolandscape <- do.call(what = raster::stack, args = c(predictor_list_nolandscape, quick = FALSE))

biased_swd_nolandscape <- prepareSWD(species = "Scolopax minor", 
           env = predictor_stack_nolandscape, 
           p = rename(as.data.frame(used@coords), x = coords.x1, y = coords.x2), 
           a = as.data.frame(avail_biased@coords))# categorical = c("nlcd2016_forestpatches") 

biased_swd_folds_nolandscape <- randomFolds(biased_swd_nolandscape, k = 5, only_presence = TRUE, seed = 8)

rf_biased_nolandscape <- train(method = "RF", data = biased_swd_nolandscape, biased_swd_folds_nolandscape)

#exclude moisture suite
predictor_list_nomoisture <- c(pland_1k_5k, ai_1k_5k, cohesion_1k_5k, ed_1k_5k, forest_30m, elev_30m, slope_30m)

predictor_list_nomoisture <- map(predictor_list_nomoisture, function(x){
  resample(x, forest_30m)
})

predictor_stack_nomoisture <- do.call(what = raster::stack, args = c(predictor_list_nomoisture, quick = FALSE))

biased_swd_nomoisture <- prepareSWD(species = "Scolopax minor", 
           env = predictor_stack_nomoisture, 
           p = rename(as.data.frame(used@coords), x = coords.x1, y = coords.x2), 
           a = as.data.frame(avail_biased@coords))# categorical = c("nlcd2016_forestpatches") 

biased_swd_folds_nomoisture <- randomFolds(biased_swd_nomoisture, k = 5, only_presence = TRUE, seed = 8)

rf_biased_nomoisture <- train(method = "RF", data = biased_swd_nomoisture, biased_swd_folds_nomoisture)
```

Landscape suite importance: delta AUC 0.0128061
Moisture suite importance: delta AUC -0.0247774
```{r}
auc(rf_biased_nolandscape, test = TRUE)
auc(rf_biased_nomoisture, test = TRUE)
```

Preparing a better jacknifing figure showing the AUC penalty associated with single variable and suite model exclusion
Based on biased RF (reference 0.6995656)

Variable importance is measured as the reduction in AUC when the variable/suite is removed from the full model. 

Variables with positive values improve our predictive capacity, and variables with negative values detract from it 

Asterisk indicates a suite of highly correlated variables
```{r}
jacknife_df <- tibble(`Excluded Variable/Suite` = as_factor(c("Soil Moisture*",  "Elevation", "Landscape*", "Slope", "Forest")), `Variable Importance` = c (-0.0247774, -0.0112486,  0.0128061, 0.017146, 0.0455421))

jacknife_df %>%
  mutate(pos_neg = if_else(`Variable Importance` > 0, 'a', 'b')) %>%
ggplot(mapping = aes(x = `Excluded Variable/Suite`, y = `Variable Importance`, fill = pos_neg)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  scale_fill_manual(values = c("#06A4C5", "#C52706")) +
  theme(legend.position = "none") +
  ylim(-0.03, 0.05)

#ggsave("variable_importance_1_31_21.jpg")
```



